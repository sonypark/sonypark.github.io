<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>SONY_DEV</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2019-01-15T14:16:59+09:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>sonypark</name>
   <email></email>
 </author>

 
 <entry>
   <title>패스트캠퍼스_파이썬중급_01</title>
   <link href="http://localhost:4000/til/2019/01/15/py-fastcampus01/"/>
   <updated>2019-01-15T00:00:00+09:00</updated>
   <id>http://localhost:4000/til/2019/01/15/py-fastcampus01</id>
   <content type="html">&lt;noscript&gt;&lt;pre&gt;## break
- loop문 안을 빠져 나올 때 쓴다
- break는 loop문 안에서만 사용 가능하다
```python
while True:
    print(&amp;quot;while&amp;quot;)
    break
```
~~~
=&amp;gt; while   # while 한 번만 출력되고 loop문 끝남
~~~
```python
for i in range(100):
    print(&amp;#39;for&amp;#39;)
    break
```
~~~
=&amp;gt; for     # for 한 번만 출력되고 loop문 끝남
~~~

## continue
- loop문 안에서 continue를 만나면 다시 loop문 처음으로 돌아간다.
- continue 밑에 코드는 실행되지 않는다.
```python
for i in range(2):
    print(&amp;#39;top&amp;#39;)
    continue
    # 이하 건너 뜀
    print(&amp;quot;bottom&amp;quot;)
```
~~~
# top 두 번 출력
=&amp;gt; top
=&amp;gt; top
~~~

## else (if, while, for)
- 조건문에서 쓰인다.
- if문 뿐 아니라 while, for문에서도 쓰인다.
```python
# random.randint(a,b)
# =&amp;gt; Return a random integer N such that a &amp;lt;= N &amp;lt;= b.
while random.randint(0,1): # 0(False) 또는 1(True) 리턴
    print(&amp;#39;while&amp;#39;)
    # break # =&amp;gt; break가 있다면 여기서 loop문 종료된다.
else:
    print(&amp;#39;else&amp;#39;)
```

- **for문에서 else문은 iterator객체가 모두 소모된 이후에 실행된다**
```python
for i in range(3):
    print(&amp;#39;for&amp;#39;)
else:
    print(&amp;#39;else&amp;#39;)
```
~~~
=&amp;gt; for # iterator 객체 3 소모
=&amp;gt; for
=&amp;gt; for
=&amp;gt; else # iterator 객체 소모 된 이후 실행
~~~

## else with try
- try문에서 else는 에러가 발생하지 않은 경우에만 실행된다.
```python
try:
    assert random.randint(0, 1)
    print(&amp;#39;try&amp;#39;)
except:
    # 만약 에러가 발생해서 예외처리되면, else구문으로 넘어가지 않고 
    # except구문에서 종료
    print(&amp;#39;except&amp;#39;)
else:
    print(&amp;#39;else&amp;#39;)
```
## finally
- 무조건 실행된다.
- 중간에 return이 있어도 finally는 실행된다.

```python
def a():
    try:
        assert random.randint(0, 1)
        print(&amp;#39;try&amp;#39;)
        return True
    except:
        print(&amp;#39;except&amp;#39;)
        return False
    else:
        print(&amp;#39;else&amp;#39;)
    finally:
        print(&amp;#39;finally&amp;#39;)
        # 에러가 발생했든, 하지 않았든 상관치 않고 실행된다.
        # 이전에 return으로 함수가 종료되어도 finally는 실행된다.
```

# 스페셜 메소드
- 파이썬 내에서 사용되는 프로토콜
- 객체에 특정 기능을 호출할 때 사용된다.

## 인스턴스 객체 생성
### instance = Class(1,2)

&amp;gt; **스페셜 메소드 호출 순서**
&amp;gt;1. `__call__`
&amp;gt;2. `__new__`
&amp;gt;3. `__init__`

## `__init__`
```python
class A:
    def __init__(self, a, b):
        # 인스턴스 생성 후 가장 먼저 실행되는 스페셜 메소드, 인스턴스 초기 설정
        print(&amp;quot;인스턴스 초기화&amp;quot;)
        self.a = a
        self.b = b

=&amp;gt; a = A(1, 2)
```
## `__new__`
- instance를 생성하는 생성자 역할
- class를 인자값으로 받아 instance를 만든다
- 오버라이딩 하는 경우 `object에 구현된 __new__`를 이용해서 instance를 만든다.


```python
class B:
    def __new__(cls): #self가 아닌 cls를 사용한다. 아직 인스턴스가 생성되지 않은 상태이기 때문에. class를 인자로 받는다.
        print(&amp;quot;인스턴스를 만듭니다.&amp;quot;)
        print(cls)
        # return 1 # 이라고 작성하면 B클래스를 호출하면 항상 1을 리턴한다.
        return super().__new__(cls)
```
```python
b = B()
```
```python
=&amp;gt; 인스턴스를 만듭니다.
=&amp;gt; &amp;lt;class &amp;#39;__main__.B&amp;#39;&amp;gt;
```

## `__call__`
```python
class C:
    def __call__(self, *args):
        print(&amp;quot;호출&amp;quot;)
```
```python
# 인스턴스를 호출할때 -&amp;gt; 즉 괄호`()`를 열고 닫을때 실행되는 메소드
c = C()
c()
```
```python
=&amp;gt; 호출
```

## 질문1
&amp;gt; - 위 `__new__`, `__call__` 예시에서
&amp;gt; - b = B()를 선언하면 `def __new__(cls)` 이 실행되는데
&amp;gt; - c = C()를 선언한 이후에 c()를 입력해야 `def __call__(self, *args)` 이 실행됩니다.
&amp;gt; - 그 이유가 무엇인가요?


~~~
클래스를 호출할때 실행되는 `__call__` 스페셜 메소드는 어디에 있을까?
=&amp;gt; 클래스를 만드는 메타클래스인 `type`클래스에 있는 `__call__`을 호출함
~~~
```python
type(C) # 클래스의 type 확인 / 즉 C class 객체를 생성한 클래스를 확인
```

```python
=&amp;gt;type
```

## 커스텀 메타 클레스 만들기
```python
class TypeClass(type):
    def __call__(cls, *args):
        print(&amp;#39;call&amp;#39;)
        instance = cls.__new__(cls)
        instance.__init__(*args)
        return instance
```



## 질문2
&amp;gt; - instance = `cls.__new__(cls)`
&amp;gt; - 이 부분의 의미를 잘 모르겠습니다.
&amp;gt; - TypeClass(type) 안에는 `__new__(cls)`라는 함수가 존재하지 않는데 어떻게 이렇게 선언할 수 있나요?
&amp;gt; - instance = `cls.__new__(cls)`
&amp;gt; - instance.`__init__(*args)`
&amp;gt; - 이 두 부분에 대해 설명 부탁드립니다.



## 커스텀 메타클래스 적용시키는 방법
- class A(metaclass=TypeClass): in v3

```python
class A(metaclass=TypeClass):
    def __new__(cls):
        print(&amp;#39;new&amp;#39;)
        return super().__new__(cls)
    
    def __init__(self, x, y, z):
        print(&amp;#39;init&amp;#39;)
        self.x = x
        self.y = y
        self.z = z
```


## 질문3
&amp;gt; - `return super().__new__(cls)`
&amp;gt; - 이 부분이 의미하는 바를 정확히 모르겠습니다.
&amp;gt; - 저 부분을 return함으로서 생기는 결과가 무엇인가요?


```python
instance = A(1, 2, 3)
```
```python
# 순서대로 호출
=&amp;gt; call
=&amp;gt; new
=&amp;gt; init
```



## 싱글턴
- 최초에 생성한 인스턴스만 리턴해주는 클래스
```python
class St:
    def __new__(cls):
        if not hasattr(cls, &amp;#39;instance&amp;#39;):
            cls.instance = super().__new__(cls)
        return cls.instance
```
```python
St() is St()
```
```python
=&amp;gt; True
```


## 질문4
&amp;gt; - 싱글턴
&amp;gt; - 싱글턴을 설명하는 위의 코드가 잘 이해되지 않습니다.
&amp;gt; - return에 `super().__new__(cls)` 로 쓸 때와의 차이점은 무엇인가요?
&amp;gt; - 싱글턴을 사용하는 상황과 예시는 어떤 게 있나요?


## with(context 관리)
~~~
with -&amp;gt; &amp;#39;__enter__&amp;#39;, &amp;#39;__exit__&amp;#39; 순으로 진행된다.
시작할 때 enter, 끝날 때 exit 가 실행된다. 

__enter__ : with구문 시작할때,
__exit__: with구문 (들여쓰기가) 끝날때

파일을 열 때 with을 쓰는 이유는 __exit__ 부분에서 f.close를 자동으로 해주기 때문이다.
~~~

```python
class Context:
    def __enter__(self):
        print(&amp;quot;__enter__&amp;quot;)
        return self
    
    def __exit__(self, *args):
        print(&amp;#39;exit&amp;#39;)
```
```python
c = Context()
```
```python
with c: # __enter__
    with c: # __enter__
        with c: # __enter__
            pass # __exit__
        pass # __exit__
    pass # __exit__

```
```python
=&amp;gt; __enter__
=&amp;gt; __enter__
=&amp;gt; __enter__
=&amp;gt; exit
=&amp;gt; exit
=&amp;gt; exit
```

```python
f = open(&amp;quot;./test.txt&amp;quot;, &amp;#39;w&amp;#39;)
hasattr(f, &amp;#39;__enter__&amp;#39;), hasattr(f, &amp;#39;__exit__&amp;#39;)
```
```python
=&amp;gt; (True, True)
```
```python
f.close()
f.closed 
```
```python
=&amp;gt; True
```
```python
c = Context()
with c:
    pass
--------------------
with Context() as c:
    pass
    
는 동일한 실행 방법이다
```

##### 파일래퍼객체에는 with구문안에서 사용될 수 있도록 스페셜 메소드가 구현되어 있다.
```python
f = open(&amp;quot;./test.txt&amp;quot;, &amp;#39;w&amp;#39;)
hasattr(f, &amp;#39;__enter__&amp;#39;), hasattr(f, &amp;#39;__exit__&amp;#39;)
```
```python
=&amp;gt; (True, True)
# __exit__메소드가 실행될 때, .close()메소드가 실행되서 파일io를 종료한다.
```

----

## `__exit__` 스페셜 메소드에 들어오는 인자는??

### `def __exit__(self, error_type, error, traceback):`

`error_type` : with구문 안에서 발생한 에러의 클래스

`error`: with구문 안에서 발생한 에러의 인스턴스

`traceback`: with구문 안에서 발생한 에러의 traceback

&amp;gt; traceback은 추후에 수업 예정



이러한 인자를 받기 때문에,     
with구문 안에서 에러가 발생한 경우에 대처할 수 있게 된다.


만약 에러가 발생하지 않으면 `None, None, None`이 들어온다


```python
class Context:
    def __enter__(self):
        print(&amp;quot;__enter__&amp;quot;)
        return self
    
    def __exit__(self, error_cls, error_instance, traceback):
        print(&amp;#39;exit&amp;#39;)
```

```python
c = Context()
```

```python
with c:
    raise IndexError(&amp;quot;인스턴스입니다.&amp;quot;)
```
```python
__enter__
exit
(&amp;lt;class &amp;#39;IndexError&amp;#39;&amp;gt;, IndexError(&amp;#39;인스턴스입니다.&amp;#39;), &amp;lt;traceback object at 0x1083c5dc8&amp;gt;)
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
&amp;lt;ipython-input-150-68d46299f410&amp;gt; in &amp;lt;module&amp;gt;
      1 with c:
----&amp;gt; 2     raise IndexError(&amp;quot;인스턴스입니다.&amp;quot;)

IndexError: 인스턴스입니다.
```

## with 활용 2

`python trick` 책에서 나온 예제.

참고주소 : https://realpython.com/
&amp;gt; 메일링 서비스 신청하면 좋습니다. 좋은 주제 많이 이야기하는 파이썬 블로그입니다. (현솔 강사님 추천)

```python
class Indenter:
    def __init__(self):
        self.level = 0
        
    def __enter__(self):
        self.level += 1
        return self
    
    def __exit__(self, *args):
        self.level -= 1
        
    def print(self, text):
        print(&amp;quot;    &amp;quot; * self.level + text)
```
```python
with Indenter() as indent:
    indent.print(&amp;quot;hi&amp;quot;)
    with indent:
        indent.print(&amp;quot;hello&amp;quot;)
        with indent:
            indent.print(&amp;#39;안녕하세요&amp;#39;)
        indent.print(&amp;#39;bye&amp;#39;)
    indent.print(&amp;quot;quit&amp;quot;)
```
~~~
    hi
        hello
            안녕하세요
        bye
    quit
~~~

# 자료구조(tuple, list, dict, set, str)
- 2 종류의 추상클래스로 묶어서 이해하기
- Container 와 Sequence(Container + 순서 정보)

## Container
- __contains__ 가 구현되어 있는 객체
- __contains__를 함수가 아닌 상수로 선언해도 Container로 인지한다.
~~~
class MC:
    def __contains__(self, value):
        return True
    
    # __contains__ = 1  # 메소드가 아닌 경우에도 Container객체라고 판단함.
~~~
```python
issubclass(MC, Container)
```
```python
=&amp;gt; True
```
## Container의 특징
#### in ( not in ) : 포함 여부
#### len : 길이
#### max,min : 최대값, 최소값

## Sequence
- container + 순서

## Sequence 특징
#### 더하기 연산 +

```
[1, 2, 3] + [4, 5, 6]
=&amp;gt; [1, 2, 3, 4, 5, 6]
```
#### 곱하기 연산 (* n)

```
[1, 2] * 10
=&amp;gt; [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
```
#### indexing 색인

```
[1, 2, 3][0]
=&amp;gt; 1
```
#### slice

```
a = [1, 2, 3, 4]
a[1:3] #  == a[slice(1, 3)] 슬라이스객체로 인덱싱하는것이랑 동일
```

## super 클래스

```python
class Z:
    def a(self):
        print(&amp;quot;a in Z&amp;quot;, self)
        
class A(Z):
    def a(self):
        print(&amp;quot;a in A&amp;quot;, self)
        
        
class C:
    def a(self):
        print(&amp;quot;a in C&amp;quot;, self)
        
        
class B(A, C):
    def a(self):
        print(&amp;quot;a in B&amp;quot;, self)  

```

```python
B.mro()
```
```python
[__main__.B, __main__.A, __main__.Z, __main__.C, object]
```
```python
b = B()
b.a() # B.mro() 순서대로 메소드를 탐색해서 실행시킴
```

```python
=&amp;gt; a in B &amp;lt;__main__.B object at 0x108445c18&amp;gt;
```

## super(기준 클래스, 인스턴스)
- 기준 클래스는 무시 -&amp;gt; mro 기준 다음 클래스부터 탐색

```python
super(B, b).a()
```
```python
=&amp;gt; a in A &amp;lt;__main__.B object at 0x108420dd8&amp;gt;
```
```python
B.mro()
```
```python
==&amp;gt; [__main__.B, __main__.A, __main__.Z, __main__.C, object]
```
```python
super(B, b).a()
```
```python
==&amp;gt; a in A &amp;lt;__main__.B object at 0x108420dd8&amp;gt;
```
```python
super(A, b).a()
```
```python
==&amp;gt; a in Z &amp;lt;__main__.B object at 0x108420dd8&amp;gt;
```
```python
super(C, b).a()
```
```python
==&amp;gt; Error   #(C 뒤에는 Object 이기 때문)
```

```python
class B:
    def bm(self):
        print(&amp;#39;b in B&amp;#39;)
        
class A(B):
    def bm(self):
        print(&amp;#39;b in A&amp;#39;)
        
    def am(self):
        super().bm() # == super(A, self).bm() 작성한 것과 동일
        # 클래스 안에서 사용하면 자동으로, 속한 클래스와 인스턴스를 인자로 보냄
```

```python
instance = A()
instance.am()
```
```python
=&amp;gt; b in B
```
```python
A.am()
```
```python
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&amp;lt;ipython-input-291-bb4ec2b72093&amp;gt; in &amp;lt;module&amp;gt;
----&amp;gt; 1 A.am()

TypeError: am() missing 1 required positional argument: &amp;#39;self&amp;#39;
```&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/sonypark/e11d1e247b7975c31a894b9981f8e506.js&quot;&gt; &lt;/script&gt;

</content>
 </entry>
 
 <entry>
   <title>TIL_190114</title>
   <link href="http://localhost:4000/til/2019/01/14/TIL/"/>
   <updated>2019-01-14T00:00:00+09:00</updated>
   <id>http://localhost:4000/til/2019/01/14/TIL</id>
   <content type="html">&lt;h1 id=&quot;오늘-한-일&quot;&gt;오늘 한 일&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;생활코딩 &lt;a href=&quot;https://opentutorials.org/course/1750&quot;&gt;Python&amp;amp;Ruby 강의&lt;/a&gt; 완강&lt;/li&gt;
  &lt;li&gt;깃헙 블로그 재설치&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;느낀점&quot;&gt;느낀점&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;생활코딩 &lt;a href=&quot;https://opentutorials.org/course/1750&quot;&gt;Python&amp;amp;Ruby 강의&lt;/a&gt;를 완강했다. 예전에 필요해서 공부한 경험이 있었지만 이번 기회에 기초 지식을 좀 더 단단히 할 수 있었다. 수업을 들으며 그 동안 가졌더 의문이 많이 해결 되었다.&lt;/li&gt;
  &lt;li&gt;실수로 깃헙 블로그 데이터를 모두 날렸다. 블로그 수정을 하려다 git push를 잘 못 했고 그 걸 되돌리려다 완전히 다 날려버렸다. 그래서 처음부터 다시 깔았다.. 불행 중 다행인 건 그 동안 게시했던 포스팅(얼마 없지만..)은 따로 백업해두었다는 것이었다. 아직 git 명령어에 익숙지 않아 자칫 하면 데이터를 크게 날릴 위험이 있다. 앞으로는 git 공부도 열심히 해야겠다.&lt;/li&gt;
  &lt;li&gt;블로그 시작 초반이고 포스팅이 몇 개 없어서 망정이지 그렇지 않았다면 엄청난 멘붕에 휩싸였을 것 같다. 오늘 일을 교훈 삼아 앞으로 더 주의하자.&lt;/li&gt;
  &lt;li&gt;강제 푸시(git push –force)는 정말 위험하다..
    &lt;h1 id=&quot;내일-할-일&quot;&gt;내일 할 일&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;영어공부: 생활 영어 표현 5개 암기 및 작문&lt;/li&gt;
  &lt;li&gt;파이썬 교재 1독(복습) - 점프투파이썬&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>TIL_190113</title>
   <link href="http://localhost:4000/til/2019/01/13/TIL/"/>
   <updated>2019-01-13T00:00:00+09:00</updated>
   <id>http://localhost:4000/til/2019/01/13/TIL</id>
   <content type="html">&lt;h1 id=&quot;오늘-한-일&quot;&gt;오늘 한 일&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;생활코딩 &lt;a href=&quot;https://opentutorials.org/course/1750&quot;&gt;Python&amp;amp;Ruby 강의&lt;/a&gt; 수강&lt;/li&gt;
  &lt;li&gt;영어공부 : 생활영어 표현 5개 암기 및 영어 작문&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;느낀점&quot;&gt;느낀점&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;파이썬을 제대로 공부한 적이 없어서 그런지 생활코딩, 패스트캠퍼스의 파이썬 강의를 통해 많이 배운다.&lt;/li&gt;
  &lt;li&gt;이전에는 딥러닝을 공부하면서 Scrapy 크롤링이나 CNN 모델을 테스트 하기 위해 그 때 그 때 필요한 부분만 찾아서 공부했다. 그래서 파이썬 언어의 기본 문법이나 구조를 제대로 알지 못하고 사용했다. (&lt;code class=&quot;highlighter-rouge&quot;&gt;__init__&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; 등)&lt;/li&gt;
  &lt;li&gt;파이썬을 처음부터 다시 공부하면서 객체 지향 프로그래밍에 대해서도 다시 한 번 되짚어 볼 수 있어 좋다.&lt;/li&gt;
  &lt;li&gt;오늘은 좀 게으름을 피웠다. 일요일이라 그런지 좀 쉬고 싶은 마음도 있었다. 내일부터는 다시 부지런히 공부해야겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;내일-할-일&quot;&gt;내일 할 일&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;생활코딩 &lt;a href=&quot;https://opentutorials.org/course/1750&quot;&gt;Python&amp;amp;Ruby 강의&lt;/a&gt; 듣기&lt;/li&gt;
  &lt;li&gt;영어공부: 생활 영어 표현 5개 암기 및 작문&lt;/li&gt;
  &lt;li&gt;파이썬 교재 1독(복습) - 점프투파이썬&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>TIL_190112</title>
   <link href="http://localhost:4000/til/2019/01/12/TIL/"/>
   <updated>2019-01-12T00:00:00+09:00</updated>
   <id>http://localhost:4000/til/2019/01/12/TIL</id>
   <content type="html">&lt;h1 id=&quot;오늘-한-일&quot;&gt;오늘 한 일&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;패스트캠퍼스 파이썬 중급 강의 첫 수업 수강&lt;/li&gt;
  &lt;li&gt;수업 내용 복습 : &lt;a href=&quot;https://gist.github.com/sonypark/e11d1e247b7975c31a894b9981f8e506&quot;&gt;gist.github.com&lt;/a&gt;에 업로드&lt;/li&gt;
  &lt;li&gt;영어공부 : 생활영어 표현 5개 암기 및 영어 작문&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;느낀점&quot;&gt;느낀점&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;나는 그 동안 파이썬의 10%도 사용하지 못 하고 있었다.&lt;/li&gt;
  &lt;li&gt;수업 듣길 잘 했다.&lt;/li&gt;
  &lt;li&gt;markdown 문법에 조금씩 익숙해지고 있다. Github page 와 gist 를 시작하길 잘 한 것 같다.&lt;/li&gt;
  &lt;li&gt;앞으로 파이썬 강의 내용을 복습한 후 gist에 올리고 그 중에서 특히 도움이 되는 내용은 Github page에 올리자&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;내일-할-일&quot;&gt;내일 할 일&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;생활코딩 &lt;a href=&quot;https://opentutorials.org/course/1750&quot;&gt;Python&amp;amp;Ruby 강의&lt;/a&gt; 듣기&lt;/li&gt;
  &lt;li&gt;영어공부: 생활 영어 표현 5개 암기 및 작문&lt;/li&gt;
  &lt;li&gt;파이썬 교재 1독(복습) - 점프투파이썬&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>TIL_190111</title>
   <link href="http://localhost:4000/til/2019/01/11/TIL-02/"/>
   <updated>2019-01-11T00:00:00+09:00</updated>
   <id>http://localhost:4000/til/2019/01/11/TIL-02</id>
   <content type="html">&lt;h1 id=&quot;오늘-한-일&quot;&gt;오늘 한 일&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;생활코딩 &lt;a href=&quot;https://opentutorials.org/course/1750&quot;&gt;Python&amp;amp;Ruby 강의&lt;/a&gt; 듣기&lt;/li&gt;
  &lt;li&gt;영어공부 : 생활영어 표현 5개 암기 및 영어 작문&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;느낀점&quot;&gt;느낀점&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;주석을 달 때 규칙&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;&lt;strong&gt;간결하면서 이해하기 쉽게 달 것&lt;/strong&gt;&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;주석을 달 필요 없는 코드를 작성할 것&lt;/strong&gt;&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; - 코드만 보고도 이해 할 수 있게 작성하는 게 중요하다
 - 최고의 주석은 '주석이 필요 없는 코드'이다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;내일-할-일&quot;&gt;내일 할 일&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;패스트캠퍼스 파이썬 강의 첫 수업&lt;/li&gt;
  &lt;li&gt;생활코딩 &lt;a href=&quot;https://opentutorials.org/course/1750&quot;&gt;Python&amp;amp;Ruby 강의&lt;/a&gt; 듣기&lt;/li&gt;
  &lt;li&gt;영어공부: 생활 영어 표현 5개 암기 및 작문&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>TIL_190110</title>
   <link href="http://localhost:4000/til/2019/01/10/TIL/"/>
   <updated>2019-01-10T00:00:00+09:00</updated>
   <id>http://localhost:4000/til/2019/01/10/TIL</id>
   <content type="html">&lt;h1 id=&quot;오늘-한-일&quot;&gt;오늘 한 일&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt; 테마로 깃헙 블로그 론칭. 이거 만드는 데만 이틀을 꼬박 보냈다. 여러 테마를 적용해보며 10번 넘게 설치와 삭제를 반복했다.(예쁘고 맘에 드는 테마일 수록 설정이 복잡하다.. 결국 처음에 고른 가장 간단한 테마로 결정)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/codinfox/codinfox-lanyon&quot;&gt;codinfox&lt;/a&gt; 탬플릿을 사용했다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;템플릿과 TIL(Today I Learned) 작성 형식&lt;/strong&gt;은 &lt;a href=&quot;https://wayhome25.github.io/&quot;&gt;초보몽키&lt;/a&gt;님의 블로그를 참고했다.&lt;/li&gt;
      &lt;li&gt;TIL을 시작하기로 마음 먹은 것도 초보몽키님의 TIL을 보고 자극을 받았기 때문이다.&lt;/li&gt;
      &lt;li&gt;아직 템플릿과 포스팅이 익숙지 않아서 초보몽키님의 블로그를 참고하며 앞으로도 많이 도움을 받을 것 같다.&lt;/li&gt;
      &lt;li&gt;이곳도 언젠간 누군가에게 도움을 주는 블로그가 되었으면 좋겠다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;생활코딩 &lt;a href=&quot;https://opentutorials.org/course/1750&quot;&gt;Python&amp;amp;Ruby 강의&lt;/a&gt; 듣기&lt;/li&gt;
  &lt;li&gt;영어공부 : 생활영어 표현 5개 암기 및 영어 작문&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;느낀점&quot;&gt;느낀점&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;너무 조급해 하지 말자. 빨리 가려다 중요한 걸 놓친다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;공부할 게 많다 보니 조급해진다. 그러다 보니 기초적인 걸 건너뛰고 싶어질 때가 있다. 하지만 기초가 가장 중요하다. 구현에만 급급하지 말고 언어의 구성요소와 작동원리 등도 차근차근 공부하자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;나무보다는 숲을 보자. 정말 중요한 것에 집중하자.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;중심보다 주변적인 것에 시간을 너무 많이 썼다.
        &lt;ol&gt;
          &lt;li&gt;깃헙 블로그도 좀 더 멋진 테마를 사용 하고 싶어서 테마를 깔았다 지웠다만 10번을 넘게 했다. 지금 내게 중요한 건 디자인 보다는 내가 공부한 내용을 꾸준히 올리는 것이다.&lt;/li&gt;
          &lt;li&gt;파이썬과 루비를 Atom 에디터를 쓰면 한 번에 실습 가능한데 굳이 jetbrains IDE를 따로따로 설치했다. 앞으로 계속 쓸 IDE 이기 때문에 큰 잘못은 아니지만 지금 내게 필요한 작업을 하는데는 Atom으로 충분했다. 지금 중요한 게 무엇인지 먼저 생각하고 거기에 집중하도록 하자.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;개발자에게 영어란 가장 강력한 무기이다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;영어를 몰라도 개발을 할 수는 있지만 개발을 통해 더 빨리 더 많은 것을 하기 위해선 영어가 필수이다.&lt;/li&gt;
      &lt;li&gt;특히 공부를 하다 문제가 생겼을 때 해결해줄 수 있는 대부분의 컨텐츠는 영어로 되어있다. 실제로 개발 도중 오류가 나거나 궁금한 게 있을 때 한국어보다 영어 컨텐츠를 통해 해결한 경우가 많다.&lt;/li&gt;
      &lt;li&gt;영어 공부도 개발 공부 못지 않게 매일 꾸준히 해야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;내일-할-일&quot;&gt;내일 할 일&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;생활코딩 &lt;a href=&quot;https://opentutorials.org/course/1750&quot;&gt;Python&amp;amp;Ruby 강의&lt;/a&gt; 듣기&lt;/li&gt;
  &lt;li&gt;영어공부: 생활 영어 표현 5개 암기 및 작문&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>TIL (Today I learned) 시작</title>
   <link href="http://localhost:4000/til/2019/01/10/TIL-01/"/>
   <updated>2019-01-10T00:00:00+09:00</updated>
   <id>http://localhost:4000/til/2019/01/10/TIL-01</id>
   <content type="html">&lt;p&gt;오늘 하루 공부한 내용과 느낀점을 남기는 공간&lt;/p&gt;

</content>
 </entry>
 

</feed>
