
2019년 10월 2일

# 백준 2506 - 점수계산 {docsify-ignore-all}

> 출처: https://www.acmicpc.net/problem/2506

## 문제

OX 문제는 맞거나 틀린 두 경우의 답을 가지는 문제를 말한다. 여러 개의 OX 문제로 만들어진 시험에서 연속적으로 답을 맞히는 경우에는 가산점을 주기 위해서 다음과 같이 점수 계산을 하기로 하였다. 1번 문제가 맞는 경우에는 1점으로 계산한다. 앞의 문제에 대해서는 답을 틀리다가 답이 맞는 처음 문제는 1점으로 계산한다. 또한, 연속으로 문제의 답이 맞는 경우에서 두 번째 문제는 2점, 세 번째 문제는 3점, …, K번째 문제는 K점으로 계산한다. 틀린 문제는 0점으로 계산한다.

예를 들어, 아래와 같이 10 개의 OX 문제에서 답이 맞은 문제의 경우에는 1로 표시하고, 틀린 경우에는 0으로 표시하였을 때, 점수 계산은 아래 표와 같이 계산되어, 총 점수는 1+1+2+3+1+2=10 점이다.

#### 입력

첫째 줄에 문제의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에는 N개 문제의 채점 결과를 나타내는 0 혹은 1이 빈 칸을 사이에 두고 주어진다. 0은 문제의 답이 틀린 경우이고, 1은 문제의 답이 맞는 경우이다

#### 출력

첫째 줄에 입력에서 주어진 채점 결과에 대하여 가산점을 고려한 총 점수를 출력한다.

#### 예제 입력1

```
10
1 0 1 1 1 0 0 1 1 0
```

#### 예제 출력1

```
10
```

## 접근 방법

- count 변수를 이용해 연속된 답의 갯수를 체크한다.
- 전체 총합을 담을 변수 answer를 선언한다.
- for 문을 돌면서 정답 유무를 체크한다.
- 답을 맞췄으면 count+1 해주고 answer에 count를 더해준다.
- 답을 못 맞췄으면 count=0 으로 초기화 해준다.
- for 순회가 끝나면 answer를 출력한다.

## 내 풀이

```python
import sys
n = int(input())
arr = list(map(int, sys.stdin.readline().split()))

count = 0
answer = 0
for i in range(len(arr)):
    if arr[i] == 1:
        count +=1
        answer +=count
    elif arr[i] == 0:
        count =0
print(answer)
```

## 느낀점

- 정답률 80% 이상인 매우 쉬운 문제다.
- 5개월 전에 풀었던 문제인데 그 당시에는 쉬운 문제임에도 푸는데 시간이 좀 걸렸던 걸로 기록되어있다.
- 당시 블로그 기록을 보면 "문제마다 쉽게 푸는 유형이 있고 어려운 유형이 있는데 이 문제는 후자인 것 같다."라고 되어 있다.
- 지금은 왜 그때 어려워했는지 잘 이해는 못하지만 지금은 이런 문제는 빠르고 쉽게 풀 수 있게 되었다.
- 알고리즘을 문제를 풀 때 키보드에 먼저 손이가기 보다는 펜을 들고 어떻게 풀지 노트에 적어본 후 코드를 치는 게 훨씬 효율적이라는 걸 느낀다. (결국은 생각을 코드로 옯기는 거니까)
- 알고리즘 문제를 풀때는 키보드 이전에 펜을 먼저 잡도록하자.
